function passFail = gaussPosFilter(rotImMat, centroid1, centroid2, rThresh, midRatio)
%%gaussPosFilter Determine if rotated image contains a Gaussian-like signal
%%approximately in the middle of two given centroids.
%
%   input :
%       rotImMat : A 3D matrix containing the rotated image planes for a
%       single timepoint. Dimesions are Y,X,Z. Typically generated by the
%       cropCellRotation function.
%
%       centroid1 : A vector containing the Y,X, and Z coordinates for a
%       point of interest. Usually the brightest pixel of a spindle pole
%       body foci.
%
%       centroid2: A vector containing the Y,X, and Z coordinates for a
%       point of interest. Usually the brightest pixel of a spindle pole
%       body foci.
%
%       rThresh : A double specifying the r-square value a signal must meet to
%       be classifed as 'Gaussian-like.'
%
%       midRatio : A double specifying what fraction of the centroid to
%       centroid distance the center of the signal (mu) must be within to
%       pass the position test. Recommended value of 0.33 (i.e. middle
%       third).
%
%   output :
%       passFail = A logical value of 1 if image matrix contains a
%       Gaussian-like signal along the centroid-specified axis and the
%       center of that signal (mu) is within specified distance between the
%       two centroids.
%
%   Written by Josh Lawrimore, 1/25/2019

%% Convert 3D image matrix to maximum intensity projection
mip = max(rotImMat, [], 3);
%% Parse centroids for coordinate information
% hard coded that the ROI will be 7 pixels tall
% this is set due to out pixel size of ~64.5 and the diffraction of light
rows = floor(centroid1(1))-2:ceil(centroid2(1))+3;
if isempty(rows)
    rows = floor(centroid2(1))-2:ceil(cnetroid1(1))+3;
end
cols = floor(centroid1(2)):ceil(centroid2(2));
if isempty(cols)
    cols = floor(centroid2(2)):ceil(centroid1(2));
end
mipTight = mip(rows, cols);
%% Fit ROI to a Gaussian-over-noise
vector = sum(mipTight);
[mu, rsquare] = noisedGaussFit(vector);
%% Determine if mu of fit is within specified region
minRatio = (1 - midRatio)/2;
maxRatio = 1 - minRatio;
positionTest = mu > minRatio*length(vector) | mu < maxRatio*length(vector);
passFail = positionTest && rsquare > rThresh;